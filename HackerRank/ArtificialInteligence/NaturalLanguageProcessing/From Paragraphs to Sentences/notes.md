# 문제 요약

- 주어진 문단을 문장으로 분리하라

주의사항

- .과 같은 약어를 다른 문장으로 구분시키면 안됨
- “”와 같은 문장도 하나의 문장으로 분류
- 느낌표 물음표는 다른 문장으로 분류

즉, tokennization을 하라는 문제이다.

# 사용된 주요 알고리즘

**정규 표현식**

- [ ] 문자 - 문자클래스
    - [abc]: a,b,c 중 한개의 문자와 매치
    - before는 정규식과 일치하는 문자인 b가 있으므로 매치된다.
    - [abc] == [a-c]
    - [a-zA-Z]: 모든 알파벳
    - [0-9]: 모든 숫자
    
    자주 사용하는 문자 클래스
    
    | 정규표현식 | 의미 | 동일한 표현 |
    | --- | --- | --- |
    | \d | 숫자 | [0-9] |
    | \D | 숫자가 아닌것 | [^0-9] |
    | \s | 공백문자 | [ \t\n\t\f\v] |
    | \S | 공백문자가 아닌것 | [^ \t\n\t\f\v] |
    | \w | 문자+숫자 | [a-zA-Z0-9] |
    | \W |  문자+숫자가 아닌것 | [^a-zA-Z0-9] |
- .(dot) 문자 - `\n`을 제외한 모든 문자
    - `a.b` : a + 모든 문자 + b, afb는 정규식과 매치됨
    - `a[.]b`: a문자와 b 문자 사이에 문자 . 그대로를 의미, a.b와 매치

- `*` 문자 - 최소 0번 이상 반복 (메모리 용량에 한계가 있어 실제로는 약 2억개의 반복)
    
    
    | 정규식 | 문자열 | 매치 여부 | 설명 |
    | --- | --- | --- | --- |
    | ca*t | ct | Yes | "a"가 0번 반복되어 매치 |
    | ca*t | cat | Yes | "a"가 0번 이상 반복되어 매치 (1번 반복) |
    | ca*t | caaat | Yes | "a"가 0번 이상 반복되어 매치 (3번 반복) |
- `+` 문자 - 최소 한번 이상 반복
    
    
    | 정규식 | 문자열 | 매치 여부 | 설명 |
    | --- | --- | --- | --- |
    | ca+t | ct | No | "a"가 0번 반복되어 매치되지 않음 |
    | ca+t | cat | Yes | "a"가 1번 이상 반복되어 매치 (1번 반복) |
    | ca+t | caaat | Yes | "a"가 1번 이상 반복되어 매치 (3번 반복) |
- { } ? - 반복 횟수 제한
    - `{m}` : ca{2}t
        
        
        | 정규식 | 문자열 | 매치 여부 | 설명 |
        | --- | --- | --- | --- |
        | ca{2}t | cat | No | "a"가 1번만 반복되어 매치되지 않음. |
        | ca{2}t | caat | Yes | "a"가 2번 반복되어 매치 |
    - `{m, n}`: ca{2,5}t
        
        
        | 정규식 | 문자열 | 매치 여부 | 설명 |
        | --- | --- | --- | --- |
        | ca{2,5}t | cat | No | "a"가 1번만 반복되어 매치되지 않음. |
        | ca{2,5}t | caat | Yes | "a"가 2번 반복되어 매치 |
        | ca{2,5}t | caaaaat | Yes | "a"가 5번 반복되어 매치 |
    - `?` : 바로 앞의 문자가 있어도 되고 없어도 됨 0번 혹은 1번
        
        
        | 정규식 | 문자열 | 매치 여부 | 설명 |
        | --- | --- | --- | --- |
        | ab?c | abc | Yes | "b"가 1번 사용되어 매치 |
        | ab?c | ac | Yes | "b"가 0번 사용되어 매치 |
    - 

# 풀이 방법

## 풀이 1

- rstrip()
    - remove white space at the end of the string

- txt = input().rstrip() + ' '
    
    input을 rstrip을 이용해서 공백을 없애주고, input string의 맨 마지막에 공백을 넣어준다. → 이는 input이 구두점으로 끝나지 않아도 정규 표현식이 맞는지를 보장해주는 방식이다. 
    
- `x = re.search(r'(.{2,}?)([\.\?\!])[\sA-Z]', txt)`
    - `(.{2,}?)`
        - `{2,}` :최소 2개 이상의 문자를 포함하는 non-greedy 매칭
        - `?` : non-greedy matching
        - 최소 2개 이상의 문자로 이루어진 문장을 찾음
    - **`([\.\?\!])`**
        - . ? ! 중 어떤 것이든 하나를 매칭함
        - ([])는 문자 클래스를 나타내며, 이 안에 있는 문자 중 하나를 매칭함
    - `[\sA-Z]`
        - 공백 문자나 대문자로 시작하는 문자열을 매칭
        - \s : 공백문자 매칭
        - A-Z: 알파벳 대문자 매칭
        - 문장이 다음에 오는 공백 문자나 대문자로 끝나는지 확인

```python
# Enter your code here. Read input from STDIN. Print output to STDOUT
import sys, re

txt = input().rstrip() + ' '

while True:
    x = re.search(r'(.{2,}?)([\.\?\!])[\sA-Z]', txt)
    if not x: break
    s = x.group(1) + x.group(2)
    print(s)
    txt = txt[len(s):]

```

### 참고한 링크

- https://www.kaggle.com/code/sudalairajkumar/getting-started-with-text-preprocessing
- https://wikidocs.net/4308
